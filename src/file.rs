// This file was generated by gir (b010d34) from gir-files (71d73f0)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals)]
#![allow(unused_unsafe)]
//#![allow(dead_code)]

use glib::object::IsA;
use glib::translate::*;

glib_wrapper! {
    pub struct File(Object<ffi::GFile>);

    match fn {
        get_type => || 0,
    }
}

impl File {
    pub fn has_parent<'a, P: IsA<File> + 'a, Q: Into<Option<&'a P>>>(&self, parent: Q) -> bool {
        unsafe {
            let parent1 = parent.into();
            //This works
            //let parent2 = parent1.to_glib_none();
            //from_glib2(ffi::g_file_has_parent(self.to_glib_none().0, parent2.0))

            //This fails
            from_glib2(ffi::g_file_has_parent(self.to_glib_none().0, parent1.to_glib_none().0))

            //This works too
            //let v=ffi::g_file_has_parent(self.to_glib_none().0, parent1.to_glib_none().0);
            //from_glib2(v)
        }
    }
}

fn from_glib2(val: gboolean) -> bool {
    !(val == GFALSE)
}

use libc::{c_void, c_int, size_t};
pub type gboolean = c_int;
pub const GFALSE:  c_int = 0;
pub const GTRUE:   c_int = 1;
pub type GType = size_t;

mod ffi {
    use super::*;

    #[repr(C)]
    pub struct GFile(c_void);

    //extern "C" {
    pub fn g_file_has_parent(_file: *mut GFile, _parent: *mut GFile) -> gboolean {
        unimplemented!();
    }

}
